<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="ぽこぽこWIZZY">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="icon" type="image/png" sizes="32x32" href="./icon/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./icon/favicon-16.png">
    <link rel="shortcut icon" href="./icon/favicon.ico">
    <link rel="apple-touch-icon" href="./icon/apple-touch-icon.png">
    <link rel="manifest" href="./site.webmanifest">
    <title>ぽこぽこWIZZY</title>
    <style>
        :root {
            --rows: 9;
            /* 行数 */
            --cols: 7;
            /* 列数 */
            --gap: 6px;
            /* マス間のすき間 */
            --pad: 10px;
            /* 盤面の内側余白 */
            --boardMax: min(92vw, 92svw);
            --cell: calc((var(--boardMax) - ((var(--cols) - 1) * var(--gap)) - (2 * var(--pad))) / var(--cols));
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            background: #2e3771;
            color: #f2f5ff;
            font-family: system-ui, sans-serif;
            display: grid;
            place-items: center;
            min-height: 100svh;
        }

        .wrap {
            width: calc(var(--cols) * var(--cell) + (var(--cols)-1) * var(--gap) + 2 * var(--pad));
            transform: translateX(-5px);
        }

        .hud {
            display: block;
            /* ← 縦並び */
            margin-bottom: 12px;
        }

        .hud>* {
            text-align: center;
            margin-bottom: 8px;
            /* 子要素の間に余白 */
        }

        .hud h1 {
            margin: 0;
            font-size: 30px;
            font-weight: 700;
        }

        .score {
            font-weight: 800;
            font-variant-numeric: tabular-nums;
        }

        .btn {
            background: #1e2448;
            border: 1px solid #36407a;
            color: #e6ebff;
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
        }

        /* 盤面 */
        .board {
            position: relative;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            width: calc(var(--cols) * var(--cell) + (var(--cols)-1) * var(--gap) + 2 * var(--pad));
            height: calc(var(--rows) * var(--cell) + (var(--rows)-1) * var(--gap) + 2 * var(--pad));
            display: grid;
            grid-template-columns: repeat(var(--cols), var(--cell));
            grid-template-rows: repeat(var(--rows), var(--cell));
            gap: var(--gap);
            padding: var(--pad);
            border-radius: 24px;
            background: linear-gradient(180deg, #121633, #0a0d22);
            box-shadow: inset 0 0 0 1px #212857, 0 10px 30px rgba(0, 0, 0, .4);
        }

        .cell {
            display: grid;
            place-items: center;
            overflow: visible;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }

        /* 外側：位置制御＆丸クリップ／ 内側：見た目 */
        .gem {
            width: 78%;
            height: 78%;
            border-radius: 50%;
            overflow: hidden;
            position: relative;
            transition: opacity .12s ease;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }

        .disk {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: #fff;
            /* ← ここをベース色として後で JS が上書き */
            background-image:
                radial-gradient(120% 120% at 30% 25%, rgba(255, 255, 255, .65), rgba(255, 255, 255, 0) 36%),
                radial-gradient(100% 100% at 65% 75%, rgba(0, 0, 0, .22), rgba(0, 0, 0, 0) 46%);
        }

        /* 選択ハイライト（発光） */
        .gem.selected {
            transform: scale(.9);
            box-shadow: 0 0 15px 5px rgba(255, 255, 255, .8);
            z-index: 2;
            /* 上に出す */
        }

        /* 消滅＆着地演出 */
        @keyframes pop {
            0% {
                transform: scale(1);
                opacity: 1
            }

            100% {
                transform: scale(0);
                opacity: 0
            }
        }

        .pop {
            animation: pop .18s ease forwards;
        }

        @keyframes squashIn {
            0% {
                transform: scaleY(.9) scaleX(1.05)
            }

            60% {
                transform: scaleY(1.12) scaleX(.92)
            }

            100% {
                transform: scale(1)
            }
        }

        .squash {
            animation: squashIn 200ms cubic-bezier(.2, .9, .2, 1);
        }

        .hint {
            margin-top: 10px;
            opacity: .8;
            font-size: 12px;
            line-height: 1.5;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1
            }

            50% {
                opacity: .3
            }
        }

        .time-low {
            animation: blink .8s linear infinite;
        }

        .skill-hud {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .skill-bar {
            position: relative;
            width: 160px;
            height: 10px;
            background: #1b2144;
            border: 1px solid #334081;
            border-radius: 999px;
            overflow: hidden;
        }

        .skill-fill {
            height: 100%;
            background: linear-gradient(90deg, #36f6ff, #7af59a);
            transition: width .2s;
        }

        .btn[disabled] {
            opacity: .5;
            cursor: not-allowed;
        }

        .skill-aim {
            outline: 2px solid rgba(255, 255, 255, .7);
            border-radius: 12px;
        }

        .result-overlay {
            position: fixed;
            inset: 0;
            background: rgba(5, 8, 20, .6);
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px);
            z-index: 1000;
        }

        .result-overlay.hidden {
            display: none;
        }

        .result-card {
            background: #111633;
            border: 1px solid #2a3374;
            border-radius: 16px;
            padding: 20px 24px;
            width: min(92vw, 420px);
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, .45);
        }

        .result-card h2 {
            margin: 0 0 8px;
            font-size: 22px;
        }

        .result-score {
            font-size: 32px;
            font-weight: 800;
            margin: 4px 0 16px;
        }

        .result-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .btn-primary {
            background: #3a5cff;
            border-color: #3a5cff;
        }

        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(5, 8, 20, .6);
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px);
            z-index: 1200;
        }

        .countdown-overlay.hidden {
            display: none;
        }

        .countdown-text {
            font-size: clamp(48px, 14vw, 120px);
            font-weight: 900;
            color: #ffffff;
            text-shadow: 0 6px 24px rgba(0, 0, 0, .45);
            animation: cdPop .45s ease;
        }

        @keyframes cdPop {
            0% {
                transform: scale(.6);
                opacity: .2;
            }

            70% {
                transform: scale(1.12);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>
    <!-- タブ用ファビコン（一般的） -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icon/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icon/favicon-16.png">
    <!-- 互換用（あれば） -->
    <link rel="shortcut icon" href="/icon/favicon.ico">

    <!-- iPhone / iPad ホーム追加用 -->
    <link rel="apple-touch-icon" href="/icon/apple-touch-icon.png">

    <link rel="manifest" href="/site.webmanifest">

    <!-- ブラウザUIのテーマカラー（任意） -->
    <meta name="theme-color" content="#123A7A">

</head>

<body>
    <div class="wrap">
        <div class="hud">
            <h1>ぽこぽこWIZZY</h1>
            <div>スコア: <span id="score" class="score">0</span></div>
            <div>残り: <span id="time" class="score">30</span> 秒</div>
            <div>コンボ: <span id="combo" class="score">0</span></div>
            <button id="reset" class="btn">リセット</button>
        </div>
        <div> <button id="skillBtn" class="btn" disabled>必殺技</button>
            <div class="skill-hud">
                <div class="skill-bar">
                    <div class="skill-fill" id="skillFill" style="width:0%"></div>
                </div>
            </div>
        </div>
        <!-- カウントダウンオーバーレイ -->
        <div id="countdown" class="countdown-overlay hidden" aria-hidden="true">
            <div class="countdown-text" id="countdownText">3</div>
        </div>
        <!-- リザルトオーバーレイ -->
        <div id="result" class="result-overlay hidden" aria-hidden="true">
            <div class="result-card">
                <h2>リザルト</h2>
                <p class="result-score"><span id="resultScore">0</span> 点</p>
                <div class="result-actions">
                    <button id="toMenu" class="btn btn-primary">メニューへ</button>
                    <button id="playAgain" class="btn">もう一度</button>
                </div>
            </div>
        </div>
        <div id="board" class="board" aria-label="Game Board" role="application"></div>
    </div>
    <script>
        (function () {
            'use strict';

            /*** ── 基本設定 ───────────────────── */
            var ROWS = 7, COLS = 7;
            var COLORS = ["#ffcd57", "#6cd5ff", "#a8f06a", "#ff7aa2", "#9f8bff"];
            var MIN_CHAIN = 3;

            /*** ── DOM参照（先に全部取る） ───── */
            var boardEl = document.getElementById('board');
            var scoreEl = document.getElementById('score');
            var resetBtn = document.getElementById('reset');
            var timeEl = document.getElementById('time');

            // 必殺UI
            var skillFill = document.getElementById('skillFill');
            var skillBtn = document.getElementById('skillBtn');

            // コンボUI（任意）
            var comboEl = document.getElementById('combo');

            /*** ── ゲーム状態 ─────────────────── */
            var grid = makeGrid(ROWS, COLS);
            var score = 0;
            var isDragging = false;
            var chain = [];
            var chainColor = null;
            var isResolving = false;

            // タイマー
            var timeLimit = 60;
            var timeLeft = timeLimit;
            var timerId = null;
            var isGameEnded = false;

            // コンボ
            var combo = 0;
            var comboTimer = null;

            // 必殺
            var skillGauge = 0;   // 0..100
            var skillReady = false;
            var skillAimMode = false;

            var resultEl = document.getElementById('result');
            var resultScoreEl = document.getElementById('resultScore');
            var playAgainBtn = document.getElementById('playAgain');
            var toMenuBtn = document.getElementById('toMenu');

            // カウントダウンUI
            var countdownEl = document.getElementById('countdown');
            var countdownTextEl = document.getElementById('countdownText');

            // キャラ（ここを変えるだけでスキルを差し替え可能）
            var currentCharacter = {
                name: 'ウィズ',
                skill: 'cross_blast' // 'cross_blast' | 'color_bomb' など
            };

            /*** ── 起動 ───────────────────────── */
            document.documentElement.style.setProperty('--rows', ROWS);
            document.documentElement.style.setProperty('--cols', COLS);

            attachEvents();
            showCountdown(startGame);

            /*** ── イベント ───────────────────── */
            function attachEvents() {
                // リセット：いつでも再開
                resetBtn.addEventListener('click', function () {
                    stopTimer();
                    showCountdown(startGame);
                });

                // 必殺ボタン
                if (skillBtn) {
                    skillBtn.addEventListener('click', function () {
                        if (!skillReady || isResolving) return;
                        skillAimMode = true;
                        boardEl.classList.add('skill-aim'); // 次のタップで狙い撃ち
                    });
                }

                // 盤面操作
                boardEl.addEventListener('pointerdown', function (e) {
                    e.preventDefault();

                    // 必殺モード：タップで発動
                    if (skillAimMode && !isResolving) {
                        var p = cellFromEvent(e);
                        if (inBounds(p.r, p.c)) triggerSkillAt(p.r, p.c);
                        return;
                    }

                    if (isResolving || isGameEnded) return;

                    var p = cellFromEvent(e);
                    if (!inBounds(p.r, p.c)) return;
                    var col = grid[p.r][p.c];
                    if (col == null) return;

                    isDragging = true;
                    chain = [];
                    chainColor = col;
                    try { boardEl.setPointerCapture(e.pointerId); } catch (_) { }
                    tryAdd(p.r, p.c);
                }, { passive: false });

                boardEl.addEventListener('pointermove', function (e) {
                    e.preventDefault();
                    if (!isDragging || isResolving) return;
                    var p = cellFromEvent(e);
                    if (!inBounds(p.r, p.c)) return;
                    tryAddOrBack(p.r, p.c);
                }, { passive: false });

                boardEl.addEventListener('pointerup', endDrag, { passive: false });
                boardEl.addEventListener('pointercancel', endDrag, { passive: false });
                boardEl.addEventListener('pointerleave', function () { if (isDragging) endDrag(); }, { passive: false });
            }

            function showCountdown(onDone) {
                // 画面ブロック
                if (countdownEl) {
                    countdownEl.classList.remove('hidden');
                    countdownEl.setAttribute('aria-hidden', 'false');
                }
                // 数字シーケンス
                var seq = ['3', '2', '1', 'GO!'];
                var i = 0;

                function step() {
                    if (!countdownTextEl) return finish();
                    countdownTextEl.textContent = seq[i];
                    // 毎ステップ軽くアニメ（クラスを付け直す）
                    countdownTextEl.classList.remove('replayAnim');
                    void countdownTextEl.offsetWidth; // Reflowでリプレイ
                    countdownTextEl.classList.add('replayAnim');

                    i++;
                    if (i < seq.length) {
                        setTimeout(step, 800); // 数字間の間隔
                    } else {
                        setTimeout(finish, 500); // 「GO!」の後のウェイト
                    }
                }

                function finish() {
                    if (countdownEl) {
                        countdownEl.classList.add('hidden');
                        countdownEl.setAttribute('aria-hidden', 'true');
                    }
                    if (typeof onDone === 'function') onDone();
                }

                step();
            }
            // アニメ再生用の軽いクラス（同じkeyframesを再適用するトリック）
            if (countdownTextEl) {
                var style = document.createElement('style');
                style.textContent = ".replayAnim{ animation: cdPop .45s ease; }";
                document.head.appendChild(style);
            }

            /*** ── ゲームループ系 ─────────────── */
            function startGame() {
                // 画面初期化
                closeResult(); // リザルトを閉じてからゲーム開始
                score = 0; scoreEl.textContent = 0;
                resetCombo();
                resetSkill();
                isResolving = false;
                isGameEnded = false;
                boardEl.style.pointerEvents = 'auto';

                // 盤面初期化
                for (var r = 0; r < ROWS; r++) for (var c = 0; c < COLS; c++) grid[r][c] = rand(0, COLORS.length - 1);
                renderAll(true);

                // タイマー開始
                timeLeft = timeLimit;
                timeEl.textContent = timeLeft;
                stopTimer();
                timerId = setInterval(tick, 1000);

                // 必殺UI反映
                updateSkillUI();
            }

            function tick() {
                if (isGameEnded) return;
                timeLeft--;
                timeEl.textContent = timeLeft;
                if (timeLeft <= 0) {
                    isGameEnded = true;
                    stopTimer();
                    gameOver();
                }
            }

            function stopTimer() {
                if (timerId) { clearInterval(timerId); timerId = null; }
            }

            function openResult(score) {
                if (resultScoreEl) resultScoreEl.textContent = score;
                if (resultEl) {
                    resultEl.classList.remove('hidden');
                    resultEl.setAttribute('aria-hidden', 'false');
                }
            }

            function closeResult() {
                if (resultEl) {
                    resultEl.classList.add('hidden');
                    resultEl.setAttribute('aria-hidden', 'true');
                }
            }

            // ボタン動作
            if (playAgainBtn) {
                playAgainBtn.addEventListener('click', function () {
                    closeResult();
                    stopTimer();
                    showCountdown(startGame);
                });
            }
            if (toMenuBtn) {
                toMenuBtn.addEventListener('click', function () {
                    location.href = 'menu.html';
                });
            }

            function gameOver() {
                resetCombo();
                stopTimer();
                isResolving = true;
                boardEl.style.pointerEvents = 'none';
                openResult(score); // ← リザルトを開く
            }

            /*** ── レンダリング ───────────────── */
            function renderAll(anim) {
                boardEl.innerHTML = '';
                var gemsToAnimate = [];

                for (var r = 0; r < ROWS; r++) {
                    for (var c = 0; c < COLS; c++) {
                        var cell = document.createElement('div'); cell.className = 'cell';
                        var gem = document.createElement('div'); gem.className = 'gem';
                        var disk = document.createElement('div'); disk.className = 'disk';
                        var idx = grid[r][c];
                        if (idx != null) disk.style.backgroundColor = COLORS[idx];
                        else gem.style.opacity = 0;

                        gem.appendChild(disk);
                        cell.appendChild(gem);
                        boardEl.appendChild(cell);

                        if (anim) {
                            var d = 0;
                            if (anim.fallDist && anim.fallDist[r] && anim.fallDist[r][c]) d = anim.fallDist[r][c];
                            if (anim.spawnDist && anim.spawnDist[r] && anim.spawnDist[r][c]) d = anim.spawnDist[r][c];
                            if (d > 0) gemsToAnimate.push({ gem: gem, dist: d });
                        }
                    }
                }

                requestAnimationFrame(function () {
                    for (var i = 0; i < gemsToAnimate.length; i++) {
                        var it = gemsToAnimate[i];
                        fall(it.gem, it.dist);
                    }
                });

                // 選択復元
                restoreSelection();
            }

            function ensureCellNodes(idx) {
                var cell = boardEl.children[idx]; if (!cell) return { cell: null, gem: null, disk: null };
                var gem = cell.firstElementChild;
                if (!gem || !gem.classList || !gem.classList.contains('gem')) {
                    gem = document.createElement('div'); gem.className = 'gem'; cell.innerHTML = ''; cell.appendChild(gem);
                }
                var disk = gem.firstElementChild;
                if (!disk || !disk.classList || !disk.classList.contains('disk')) {
                    disk = document.createElement('div'); disk.className = 'disk'; gem.appendChild(disk);
                }
                return { cell: cell, gem: gem, disk: disk };
            }

            function updateCell(r, c) {
                var idx = r * COLS + c, n = ensureCellNodes(idx), v = grid[r][c]; if (!n.cell) return;
                if (v != null) { n.disk.style.backgroundColor = COLORS[v]; n.gem.style.opacity = 1; }
                else { n.gem.style.opacity = 0; }
            }

            /*** ── 入力系 ─────────────────────── */
            function cellFromEvent(e) {
                var rect = boardEl.getBoundingClientRect();
                var cw = rect.width / COLS, ch = rect.height / ROWS;
                var x = Math.max(0, Math.min(rect.width - 1, e.clientX - rect.left));
                var y = Math.max(0, Math.min(rect.height - 1, e.clientY - rect.top));
                return { r: Math.floor(y / ch), c: Math.floor(x / cw) };
            }
            function inBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
            function adj(r1, c1, r2, c2) { var dr = Math.abs(r1 - r2), dc = Math.abs(c1 - c2); return (dr <= 1 && dc <= 1 && (dr + dc) > 0); }

            function tryAdd(r, c) {
                if (!inBounds(r, c) || grid[r][c] !== chainColor) return false;
                if (chain.length) {
                    var last = chain[chain.length - 1];
                    if (!adj(last.r, last.c, r, c)) return false;
                    for (var i = 0; i < chain.length; i++) { var p = chain[i]; if (p.r === r && p.c === c) return false; }
                }
                chain.push({ r: r, c: c });
                markSel(r, c, true);
                return true;
            }

            function tryAddOrBack(r, c) {
                if (!inBounds(r, c) || grid[r][c] !== chainColor) return;
                if (!chain.length) { tryAdd(r, c); return; }
                var last = chain[chain.length - 1];
                if (last.r === r && last.c === c) return;
                if (chain.length >= 2) {
                    var prev = chain[chain.length - 2];
                    if (prev.r === r && prev.c === c) {
                        var rem = chain.pop(); markSel(rem.r, rem.c, false); return;
                    }
                }
                for (var i = 0; i < chain.length; i++) { var p = chain[i]; if (p.r === r && p.c === c) return; }
                if (adj(last.r, last.c, r, c)) { chain.push({ r: r, c: c }); markSel(r, c, true); }
            }

            function markSel(r, c, on) {
                var idx = r * COLS + c, cell = boardEl.children[idx];
                if (!cell) return;
                var gem = cell.firstElementChild;
                if (gem) gem.classList.toggle('selected', !!on);
            }

            function restoreSelection() {
                for (var i = 0; i < chain.length; i++) { var p = chain[i]; markSel(p.r, p.c, true); }
            }

            function clearSel() {
                for (var i = 0; i < chain.length; i++) { var p = chain[i]; markSel(p.r, p.c, false); }
            }

            function endDrag() {
                if (!isDragging) return;
                isDragging = false;
                if (chain.length >= MIN_CHAIN) resolveChain();
                else { clearSel(); chain = []; chainColor = null; }
            }

            /*** ── コンボ ─────────────────────── */
            function updateComboView() { if (comboEl) comboEl.textContent = combo; }
            function resetCombo() {
                combo = 0;
                if (comboTimer) { clearTimeout(comboTimer); comboTimer = null; }
                updateComboView();
            }
            function bumpCombo() {
                combo = Math.min(combo + 1, 5);
                updateComboView();
                if (comboTimer) clearTimeout(comboTimer);
                comboTimer = setTimeout(function () { combo = 0; updateComboView(); }, 1500);
            }

            /*** ── 必殺（ゲージ/UI/発動） ─────── */
            function skillLabel() {
                var map = { cross_blast: '十字斬', color_bomb: '色爆弾' };
                var s = map[currentCharacter.skill] || '必殺技';
                return currentCharacter.name ? (currentCharacter.name + '：' + s) : s;
            }
            function updateSkillUI() {
                if (skillFill) skillFill.style.width = Math.max(0, Math.min(100, skillGauge)) + '%';
                if (skillBtn) {
                    skillBtn.disabled = !skillReady;
                    skillBtn.textContent = skillReady ? (skillLabel() + '（タップで指定）') : skillLabel();
                }
            }
            function resetSkill() {
                skillGauge = 0; skillReady = false; skillAimMode = false; updateSkillUI();
            }
            function addSkillCharge(n) {
                skillGauge += n * 6; // 調整可
                if (skillGauge >= 100) { skillGauge = 100; skillReady = true; }
                updateSkillUI();
            }
            function consumeSkill() {
                resetSkill();
            }

            // スキル一覧（ここに追加していけばOK）
            var Skills = {
                // 十字＋3x3
                cross_blast: function (r, c) {
                    var targets = new Set();
                    function k(rr, cc) { return rr + ',' + cc; }
                    // 3x3
                    for (var dr = -1; dr <= 1; dr++) {
                        for (var dc = -1; dc <= 1; dc++) {
                            var rr = r + dr, cc = c + dc;
                            if (inBounds(rr, cc)) targets.add(k(rr, cc));
                        }
                    }
                    // 十字（半径2）
                    var cross = [[-2, 0], [-1, 0], [1, 0], [2, 0], [0, -2], [0, -1], [0, 1], [0, 2]];
                    for (var i = 0; i < cross.length; i++) {
                        var rr = r + cross[i][0], cc = c + cross[i][1];
                        if (inBounds(rr, cc)) targets.add(k(rr, cc));
                    }
                    return targets;
                },
                // 色爆弾（中心と同色を全消し）
                color_bomb: function (r, c) {
                    var targets = new Set();
                    function k(rr, cc) { return rr + ',' + cc; }
                    if (!inBounds(r, c) || grid[r][c] == null) return targets;
                    var color = grid[r][c];
                    for (var rr = 0; rr < ROWS; rr++) {
                        for (var cc = 0; cc < COLS; cc++) {
                            if (grid[rr][cc] === color) targets.add(k(rr, cc));
                        }
                    }
                    return targets;
                }
            };

            function triggerSkillAt(r, c) {
                boardEl.classList.remove('skill-aim');
                if (!inBounds(r, c)) { consumeSkill(); return; }
                var fn = Skills[currentCharacter.skill];
                if (!fn) { consumeSkill(); return; }

                var targets = fn(r, c);

                // 見た目
                targets.forEach(function (kk) {
                    var parts = kk.split(','), rr = +parts[0], cc = +parts[1];
                    var idx = rr * COLS + cc, cell = boardEl.children[idx];
                    if (cell) { var gem = cell.firstElementChild; if (gem) gem.classList.add('pop'); }
                });

                // 実行
                isResolving = true;
                setTimeout(function () {
                    var cleared = 0;
                    targets.forEach(function (kk) {
                        var parts = kk.split(','), rr = +parts[0], cc = +parts[1];
                        if (grid[rr][cc] != null) { grid[rr][cc] = null; cleared++; }
                    });

                    // おまけ
                    var bonusTime = Math.min(5, Math.floor(cleared / 4));
                    if (bonusTime > 0) { timeLeft = Math.min(timeLimit, timeLeft + bonusTime); timeEl.textContent = timeLeft; }
                    var gained = 100 + cleared * 10;
                    score += gained; scoreEl.textContent = score;

                    applyGravityAndFill();
                    isResolving = false;
                    consumeSkill();
                }, 180);
            }

            /*** ── 消去→落下→補充 ─────────── */
            function resolveChain() {
                isResolving = true;

                // コンボ＆得点
                bumpCombo();
                var base = Math.floor(chain.length * chain.length * 5);
                var gained = Math.floor(base * (1 + 0.2 * combo));
                score += gained;
                scoreEl.textContent = score;

                // アニメ付与（選択分のみ）
                for (var i = 0; i < chain.length; i++) {
                    var r = chain[i].r, c = chain[i].c;
                    var idx = r * COLS + c, cell = boardEl.children[idx];
                    if (cell) { var gem = cell.firstElementChild; if (gem) gem.classList.add('pop'); }
                }

                setTimeout(function () {
                    var cleared = 0;
                    for (var i = 0; i < chain.length; i++) {
                        var r = chain[i].r, c = chain[i].c;
                        if (grid[r][c] != null) { grid[r][c] = null; cleared++; }
                    }

                    addSkillCharge(cleared); // 実際に消えた数でチャージ

                    clearSel(); chain = []; chainColor = null;

                    applyGravityAndFill();
                    isResolving = false;
                }, 200);
            }

            function applyGravityAndFill() {
                var h = cellH(), g = gapPx();
                var anim = { fallDist: Array(ROWS), spawnDist: Array(ROWS) };
                for (var r = 0; r < ROWS; r++) { anim.fallDist[r] = Array(COLS).fill(0); anim.spawnDist[r] = Array(COLS).fill(0); }

                for (var c = 0; c < COLS; c++) {
                    var write = ROWS - 1;
                    for (var r = ROWS - 1; r >= 0; r--) {
                        if (grid[r][c] != null) {
                            var v = grid[r][c];
                            if (write !== r) {
                                grid[write][c] = v;
                                grid[r][c] = null;
                                anim.fallDist[write][c] = (write - r) * (h + g);
                            }
                            write--;
                        }
                    }
                    for (var rr = write; rr >= 0; rr--) {
                        grid[rr][c] = rand(0, COLORS.length - 1);
                        anim.spawnDist[rr][c] = (rr + 1) * (h + g);
                    }
                }
                renderAll(anim);
            }

            /*** ── ユーティリティ ─────────────── */
            function makeGrid(r, c) { var a = new Array(r); for (var i = 0; i < r; i++) { a[i] = new Array(c); for (var j = 0; j < c; j++) a[i][j] = null; } return a; }
            function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
            function cellH() { var el = boardEl.querySelector('.cell'); return el ? el.clientHeight : 48; }
            function gapPx() { return 6; }
            function fall(gem, distance) {
                if (!gem) return;
                gem.style.transform = 'translateY(' + (-distance) + 'px)';
                requestAnimationFrame(function () {
                    var dur = Math.min(120 + distance * 0.08, 420);
                    gem.style.transition = 'transform ' + dur + 'ms cubic-bezier(.2,.9,.2,1)';
                    gem.style.transform = 'translateY(0)';
                    gem.addEventListener('transitionend', function h() {
                        gem.style.transition = ''; gem.style.transform = '';
                        gem.removeEventListener('transitionend', h);
                    });
                });
            }

        })();
    </script>

</body>

</html>
